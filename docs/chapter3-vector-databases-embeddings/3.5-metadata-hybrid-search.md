---
id: metadata-hybrid-search
title: Metadata Management and Hybrid Search
---

## 3.5 Metadata Management and Hybrid Search

Effective metadata management and hybrid search strategies are essential for production RAG systems. This section explores how to leverage metadata for filtering, access control, and combining vector search with traditional keyword search.

### The Role of Metadata in RAG

**Metadata** provides structured information about documents that enables:
1.  **Filtering:** Narrow search scope before vector similarity
2.  **Access Control:** Enforce permissions and data isolation
3.  **Contextual Enrichment:** Provide additional information to the LLM
4.  **Analytics:** Track usage patterns and document popularity
5.  **Hybrid Search:** Combine semantic and keyword-based retrieval

**Industrial-Grade Aspect:** In banking, metadata is critical for regulatory compliance, departmental isolation, and audit trails.

### Common Metadata Fields for Banking RAG

| Field | Type | Purpose | Example |
|-------|------|---------|---------|
| `document_id` | String | Unique identifier | `"DOC-2024-001234"` |
| `title` | String | Document title | `"Basel III Capital Requirements"` |
| `document_type` | String | Category | `"regulation"`, `"policy"`, `"memo"` |
| `department` | String | Owning department | `"compliance"`, `"risk"`, `"legal"` |
| `classification` | String | Security level | `"public"`, `"internal"`, `"confidential"` |
| `created_date` | Timestamp | Creation date | `"2024-01-15T10:30:00Z"` |
| `updated_date` | Timestamp | Last modification | `"2024-03-20T14:45:00Z"` |
| `author` | String | Document creator | `"john.doe@bank.com"` |
| `tags` | Array | Keywords | `["capital", "tier1", "cet1"]` |
| `region` | String | Geographic scope | `"US"`, `"EU"`, `"APAC"` |
| `version` | String | Document version | `"v2.1"` |
| `source_url` | String | Original location | `"https://internal.bank.com/docs/..."` |
| `page_number` | Integer | Page in source doc | `42` |
| `chunk_index` | Integer | Chunk position | `3` |
| `access_groups` | Array | Authorized groups | `["compliance_team", "executives"]` |

### Metadata Filtering Strategies

#### Pre-Filtering (Recommended)

**Approach:** Apply metadata filters before vector search to reduce search space.

**Advantages:**
*   Faster queries (search fewer vectors)
*   More relevant results (only search applicable documents)
*   Lower costs (fewer distance calculations)

**Example (Qdrant):**
```python
from qdrant_client import QdrantClient
from qdrant_client.models import Filter, FieldCondition, MatchValue

client = QdrantClient("localhost", port=6333)

# Search only compliance documents from 2024
search_result = client.search(
    collection_name="banking_docs",
    query_vector=query_embedding,
    query_filter=Filter(
        must=[
            FieldCondition(
                key="department",
                match=MatchValue(value="compliance")
            ),
            FieldCondition(
                key="created_date",
                range={
                    "gte": "2024-01-01T00:00:00Z",
                    "lt": "2025-01-01T00:00:00Z"
                }
            )
        ]
    ),
    limit=10
)
```

**Example (Pinecone):**
```python
import pinecone

index = pinecone.Index("banking-docs")

# Search with metadata filter
results = index.query(
    vector=query_embedding,
    filter={
        "department": {"$eq": "compliance"},
        "classification": {"$in": ["internal", "confidential"]},
        "created_date": {"$gte": "2024-01-01"}
    },
    top_k=10
)
```

**Industrial-Grade Aspect:** For banking, always filter by `access_groups` to enforce permissions. Never return documents the user isn't authorized to see.

#### Post-Filtering

**Approach:** Perform vector search first, then filter results by metadata.

**Disadvantages:**
*   May return fewer than K results if many are filtered out
*   Wastes computation on irrelevant vectors
*   Less efficient than pre-filtering

**Use Case:** When metadata filtering is optional or secondary to semantic relevance.

### Access Control with Metadata

#### Row-Level Security (RLS)

**Implementation Approaches:**

**1. Filter-Based Access Control:**
```python
def search_with_access_control(query_embedding, user_groups):
    """Enforce access control via metadata filtering."""
    return client.search(
        collection_name="banking_docs",
        query_vector=query_embedding,
        query_filter=Filter(
            must=[
                FieldCondition(
                    key="access_groups",
                    match=MatchAny(any=user_groups)
                )
            ]
        ),
        limit=10
    )

# Usage
user_groups = ["compliance_team", "all_employees"]
results = search_with_access_control(query_embedding, user_groups)
```

**2. Namespace/Collection Isolation:**
*   Create separate collections/namespaces per department
*   Route queries to appropriate namespace based on user

**Example (Pinecone Namespaces):**
```python
# Index documents by department
index.upsert(
    vectors=[(id, embedding, metadata)],
    namespace="compliance"
)

# Query specific namespace
results = index.query(
    vector=query_embedding,
    namespace="compliance",  # User can only access this namespace
    top_k=10
)
```

**3. Attribute-Based Access Control (ABAC):**
*   Define complex policies based on multiple attributes
*   Example: "Users in compliance can access confidential docs created in their region"

```python
def check_access(user, document):
    """ABAC policy enforcement."""
    if document["classification"] == "public":
        return True
    if document["classification"] == "confidential":
        return (
            user["department"] == document["department"] and
            user["region"] == document["region"] and
            user["clearance_level"] >= 3
        )
    return False
```

**Industrial-Grade Aspect:** For banking, implement defense-in-depth:
1.  Application-level access control (check user permissions)
2.  Database-level filtering (metadata filters)
3.  Audit logging (track all access attempts)

### Hybrid Search: Combining Vector and Keyword Search

**Motivation:** Vector search excels at semantic similarity but can miss exact keyword matches. Keyword search is precise but lacks semantic understanding. Combining both provides the best of both worlds.

#### Hybrid Search Architectures

**1. Parallel Search + Fusion**

**Approach:**
1.  Perform vector search and keyword search in parallel
2.  Merge results using a fusion algorithm

**Reciprocal Rank Fusion (RRF):**
```python
def reciprocal_rank_fusion(vector_results, keyword_results, k=60):
    """Combine rankings using RRF."""
    scores = {}
    
    for rank, doc_id in enumerate(vector_results):
        scores[doc_id] = scores.get(doc_id, 0) + 1 / (k + rank + 1)
    
    for rank, doc_id in enumerate(keyword_results):
        scores[doc_id] = scores.get(doc_id, 0) + 1 / (k + rank + 1)
    
    # Sort by combined score
    return sorted(scores.items(), key=lambda x: x[1], reverse=True)
```

**2. Weighted Combination**

**Approach:** Assign weights to vector and keyword scores based on query type.

```python
def weighted_hybrid_search(query, alpha=0.7):
    """
    alpha: weight for vector search (0-1)
    1-alpha: weight for keyword search
    """
    vector_results = vector_search(query)
    keyword_results = keyword_search(query)
    
    combined_scores = {}
    for doc_id, vec_score in vector_results.items():
        combined_scores[doc_id] = alpha * vec_score
    
    for doc_id, kw_score in keyword_results.items():
        combined_scores[doc_id] = combined_scores.get(doc_id, 0) + (1 - alpha) * kw_score
    
    return sorted(combined_scores.items(), key=lambda x: x[1], reverse=True)
```

**Industrial-Grade Aspect:** For banking, use higher alpha (0.7-0.8) for general queries and lower alpha (0.3-0.5) for queries with specific identifiers (account numbers, regulation codes).

#### Database-Native Hybrid Search

**Elasticsearch:**
```json
{
  "query": {
    "bool": {
      "should": [
        {
          "knn": {
            "field": "embedding",
            "query_vector": [0.1, 0.2, ...],
            "k": 10,
            "num_candidates": 100,
            "boost": 0.7
          }
        },
        {
          "multi_match": {
            "query": "Basel III capital requirements",
            "fields": ["title^2", "content"],
            "boost": 0.3
          }
        }
      ]
    }
  }
}
```

**Weaviate:**
```python
result = client.query.get(
    "BankingDoc",
    ["title", "content", "metadata"]
).with_hybrid(
    query="Basel III capital requirements",
    alpha=0.7,  # 0 = pure keyword, 1 = pure vector
    vector=query_embedding
).with_limit(10).do()
```

**Pinecone (Sparse-Dense):**
```python
# Create sparse vector (BM25-like)
sparse_vector = {
    "indices": [10, 45, 123],  # Token IDs
    "values": [0.5, 0.8, 0.3]  # TF-IDF weights
}

# Hybrid query
results = index.query(
    vector=dense_embedding,  # Dense vector
    sparse_vector=sparse_vector,  # Sparse vector
    top_k=10
)
```

### Query Classification for Adaptive Search

**Approach:** Classify queries to determine optimal search strategy.

**Query Types:**
1.  **Semantic Queries:** "What are the main risks in lending?" → High vector weight
2.  **Exact Match Queries:** "Find regulation 12 CFR 225.8" → High keyword weight
3.  **Hybrid Queries:** "Basel III tier 1 capital ratio" → Balanced weights

**Implementation:**
```python
import re

def classify_query(query):
    """Determine query type and optimal alpha."""
    # Check for exact identifiers
    if re.search(r'\b\d+\s*CFR\s*\d+', query):  # Regulation codes
        return "exact_match", 0.3
    if re.search(r'\b[A-Z]{2,}-\d{4}-\d+\b', query):  # Document IDs
        return "exact_match", 0.2
    
    # Check for question words (semantic)
    if any(word in query.lower() for word in ['what', 'why', 'how', 'explain']):
        return "semantic", 0.8
    
    # Default to hybrid
    return "hybrid", 0.6

query = "What is 12 CFR 225.8 about?"
query_type, alpha = classify_query(query)
results = weighted_hybrid_search(query, alpha=alpha)
```

### Metadata-Enriched Context for LLM

**Approach:** Include relevant metadata in the prompt to provide context.

**Example:**
```python
def build_augmented_prompt(query, retrieved_chunks):
    context_parts = []
    
    for chunk in retrieved_chunks:
        metadata = chunk["metadata"]
        context_parts.append(f"""
Document: {metadata['title']}
Type: {metadata['document_type']}
Date: {metadata['created_date']}
Department: {metadata['department']}

Content:
{chunk['text']}
---
""")
    
    context = "\n".join(context_parts)
    
    prompt = f"""Use the following documents to answer the question. Pay attention to the document metadata (type, date, department) when formulating your answer.

{context}

Question: {query}

Answer:"""
    
    return prompt
```

**Industrial-Grade Aspect:** For banking, including metadata helps the LLM:
*   Cite sources properly ("According to the 2024 Compliance Policy...")
*   Recognize document authority (regulations > internal memos)
*   Provide temporal context ("As of March 2024...")

### Best Practices for Metadata Management

1.  **Consistent Schema:** Define and enforce metadata schema across all documents
2.  **Validation:** Validate metadata at ingestion time
3.  **Indexing:** Ensure metadata fields are indexed for fast filtering
4.  **Normalization:** Standardize values (e.g., date formats, department names)
5.  **Versioning:** Track metadata changes over time
6.  **Documentation:** Maintain metadata field definitions and usage guidelines

### Summary

Metadata management and hybrid search are essential for production RAG. Key takeaways:

*   **Metadata enables filtering, access control, and context enrichment**
*   **Pre-filtering is more efficient than post-filtering**
*   **Access control should be enforced at multiple levels** (application, database, audit)
*   **Hybrid search combines semantic and keyword strengths**
*   **Query classification optimizes search strategy** based on query type
*   **Metadata-enriched prompts improve LLM responses**

In the next section, we'll cover vector database operations and maintenance for production systems.
