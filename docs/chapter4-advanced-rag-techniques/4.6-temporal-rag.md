---
id: temporal-rag
title: Temporal RAG and Version Control
---

## 4.6 Temporal RAG and Version Control

Regulations, policies, and financial data change over time. Temporal RAG handles time-based queries and maintains document version history, enabling queries like "What were the capital requirements in 2015?" or "How has this policy changed since last year?"

### Temporal Challenges in Banking

**Use Cases:**
- **Regulatory Evolution:** Track changes in Basel requirements across versions
- **Policy Updates:** Compare current vs. previous policy versions
- **Historical Analysis:** "What was our risk exposure in Q1 2020?"
- **Compliance Audits:** "What rules were in effect on this date?"

### Time-Aware Document Indexing

#### 1. Temporal Metadata

```python
document_metadata = {
    "id": "DOC-2024-001",
    "title": "Capital Requirements Policy",
    "version": "3.2",
    "effective_date": "2024-01-15T00:00:00Z",
    "expiry_date": "2025-01-14T23:59:59Z",  # When superseded
    "created_date": "2024-01-10T00:00:00Z",
    "previous_version_id": "DOC-2023-045",
    "change_summary": "Updated tier 1 capital ratio from 6% to 6.5%",
    "is_current": True
}
```

#### 2. Temporal Filtering

```python
def temporal_search(query, reference_date=None):
    """Search documents valid at specific date."""
    if reference_date is None:
        reference_date = datetime.now()
    
    # Filter for documents valid at reference_date
    results = vector_search_with_filter(
        query,
        filter={
            "effective_date": {"$lte": reference_date.isoformat()},
            "$or": [
                {"expiry_date": {"$gte": reference_date.isoformat()}},
                {"expiry_date": None}  # No expiry = still current
            ]
        },
        top_k=5
    )
    
    return results

# Example: What were requirements in 2020?
historical_results = temporal_search(
    "capital requirements",
    reference_date=datetime(2020, 6, 1)
)
```

#### 3. Version-Aware RAG

```python
def version_aware_rag(query, version_spec="latest"):
    """RAG with version control."""
    
    if version_spec == "latest":
        filter_condition = {"is_current": True}
    elif version_spec == "all":
        filter_condition = {}  # All versions
    elif isinstance(version_spec, datetime):
        # Specific date
        return temporal_search(query, version_spec)
    else:
        # Specific version number
        filter_condition = {"version": version_spec}
    
    results = vector_search_with_filter(query, filter_condition, top_k=5)
    return generate_answer(query, results)
```

### Change Detection and Comparison

#### 1. Document Diff

```python
import difflib

def compare_document_versions(doc_id_v1, doc_id_v2):
    """Compare two versions of a document."""
    doc_v1 = fetch_document(doc_id_v1)
    doc_v2 = fetch_document(doc_id_v2)
    
    # Text diff
    diff = list(difflib.unified_diff(
        doc_v1['text'].splitlines(),
        doc_v2['text'].splitlines(),
        lineterm='',
        fromfile=f"Version {doc_v1['version']}",
        tofile=f"Version {doc_v2['version']}"
    ))
    
    # Semantic changes (using LLM)
    changes_summary = llm_generate(f"""Summarize the key changes between these versions:

Version {doc_v1['version']}:
{doc_v1['text'][:1000]}...

Version {doc_v2['version']}:
{doc_v2['text'][:1000]}...

Key changes:""")
    
    return {
        "text_diff": "\n".join(diff),
        "semantic_changes": changes_summary,
        "metadata_changes": compare_metadata(doc_v1['metadata'], doc_v2['metadata'])
    }
```

#### 2. Temporal Query Answering

```python
def temporal_comparison_rag(query, date1, date2):
    """Answer queries comparing two time periods."""
    
    # Retrieve for both dates
    results_date1 = temporal_search(query, date1)
    results_date2 = temporal_search(query, date2)
    
    # Generate comparative answer
    prompt = f"""Compare the information from these two time periods:

Query: {query}

{date1.strftime('%Y-%m-%d')} Context:
{format_documents(results_date1)}

{date2.strftime('%Y-%m-%d')} Context:
{format_documents(results_date2)}

Comparison:"""
    
    return llm_generate(prompt)

# Example
comparison = temporal_comparison_rag(
    "What are the capital requirements?",
    datetime(2015, 1, 1),
    datetime(2024, 1, 1)
)
```

### Event-Based Temporal RAG

#### 1. Timeline Construction

```python
def build_regulation_timeline(topic):
    """Build timeline of regulatory changes."""
    
    # Retrieve all versions related to topic
    all_versions = vector_search_with_filter(
        topic,
        filter={},  # No filter, get all versions
        top_k=50
    )
    
    # Sort by effective date
    timeline = sorted(
        all_versions,
        key=lambda x: x['metadata']['effective_date']
    )
    
    # Extract key events
    events = []
    for doc in timeline:
        events.append({
            "date": doc['metadata']['effective_date'],
            "title": doc['metadata']['title'],
            "version": doc['metadata']['version'],
            "change_summary": doc['metadata'].get('change_summary', '')
        })
    
    return events
```

#### 2. Temporal Reasoning

```python
def temporal_reasoning_rag(query):
    """Handle temporal reasoning in queries."""
    
    # Extract temporal expressions
    temporal_info = extract_temporal_info(query)
    
    if temporal_info['type'] == 'point_in_time':
        # "What was X in 2020?"
        return temporal_search(query, temporal_info['date'])
    
    elif temporal_info['type'] == 'duration':
        # "How did X change from 2018 to 2022?"
        return temporal_comparison_rag(
            query,
            temporal_info['start_date'],
            temporal_info['end_date']
        )
    
    elif temporal_info['type'] == 'relative':
        # "What changed since last quarter?"
        reference_date = calculate_relative_date(temporal_info['expression'])
        return temporal_comparison_rag(query, reference_date, datetime.now())
    
    else:
        # No temporal aspect, use current data
        return standard_rag(query)
```

### Version Control Strategies

#### 1. Snapshot-Based Versioning

```python
class VersionedDocumentStore:
    def __init__(self):
        self.snapshots = {}  # date -> full index snapshot
    
    def create_snapshot(self, snapshot_date):
        """Create point-in-time snapshot."""
        current_docs = fetch_all_current_documents()
        self.snapshots[snapshot_date] = {
            "documents": current_docs,
            "index": build_vector_index(current_docs)
        }
    
    def query_snapshot(self, query, snapshot_date):
        """Query historical snapshot."""
        if snapshot_date not in self.snapshots:
            raise ValueError(f"No snapshot for {snapshot_date}")
        
        snapshot_index = self.snapshots[snapshot_date]['index']
        return snapshot_index.search(query, top_k=5)
```

#### 2. Delta-Based Versioning

```python
class DeltaVersionControl:
    def __init__(self):
        self.base_version = None
        self.deltas = []  # List of changes
    
    def add_version(self, document, change_type):
        """Track document changes."""
        delta = {
            "timestamp": datetime.now(),
            "document_id": document['id'],
            "change_type": change_type,  # 'add', 'modify', 'delete'
            "content": document if change_type != 'delete' else None
        }
        self.deltas.append(delta)
    
    def reconstruct_at_date(self, target_date):
        """Reconstruct index state at specific date."""
        documents = {}
        
        # Apply deltas up to target_date
        for delta in self.deltas:
            if delta['timestamp'] <= target_date:
                if delta['change_type'] == 'delete':
                    documents.pop(delta['document_id'], None)
                else:
                    documents[delta['document_id']] = delta['content']
        
        return list(documents.values())
```

### Best Practices

1. **Immutable History:** Never delete old versions, mark as superseded
2. **Effective Dates:** Always store when document becomes/became active
3. **Change Summaries:** Document what changed between versions
4. **Snapshot Strategy:** Balance storage costs vs. query performance
5. **Audit Trail:** Log all version changes for compliance

### Summary

Temporal RAG enables time-aware retrieval and version control. Key takeaways:

- **Temporal metadata** tracks effective dates and versions
- **Temporal filtering** retrieves documents valid at specific dates
- **Change detection** compares document versions
- **Timeline construction** visualizes regulatory evolution
- **Version control** strategies: snapshot-based vs. delta-based
- **Banking applications**: Regulatory compliance, historical analysis, audit support

Next, we'll explore cross-lingual and multilingual RAG.
