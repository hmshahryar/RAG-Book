---
id: agentic-rag
title: Agentic RAG and Tool Integration
---

## 4.4 Agentic RAG and Tool Integration

Agentic RAG extends traditional RAG by giving the LLM access to external tools and APIs, enabling it to perform actions beyond retrieval and generation. This transforms RAG from a passive Q&A system into an active agent capable of complex workflows.

### What is Agentic RAG?

**Traditional RAG:** Query → Retrieve → Generate → Answer

**Agentic RAG:** Query → Plan → Use Tools (retrieve, calculate, query APIs, execute code) → Reason → Answer

**Key Capabilities:**
- **Tool Selection:** Choose appropriate tools for the task
- **Multi-step Reasoning:** Chain multiple tool calls
- **Dynamic Planning:** Adjust strategy based on intermediate results
- **Action Execution:** Perform operations beyond text generation

**Industrial-Grade Aspect:** For banking, agentic RAG can calculate financial metrics, query transaction databases, and validate compliance rules—not just retrieve documents.

### Tool Integration Patterns

#### 1. Function Calling (OpenAI/Anthropic)

```python
from openai import OpenAI

client = OpenAI()

# Define available tools
tools = [
    {
        "type": "function",
        "function": {
            "name": "search_regulations",
            "description": "Search regulatory documents",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {"type": "string", "description": "Search query"},
                    "regulation_type": {"type": "string", "enum": ["basel", "dodd-frank", "mifid"]}
                },
                "required": ["query"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "calculate_capital_ratio",
            "description": "Calculate bank capital ratios",
            "parameters": {
                "type": "object",
                "properties": {
                    "tier1_capital": {"type": "number"},
                    "risk_weighted_assets": {"type": "number"}
                },
                "required": ["tier1_capital", "risk_weighted_assets"]
            }
        }
    }
]

def agentic_rag(query):
    """RAG with tool calling."""
    messages = [{"role": "user", "content": query}]
    
    while True:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=messages,
            tools=tools,
            tool_choice="auto"
        )
        
        message = response.choices[0].message
        
        # If no tool call, return final answer
        if not message.tool_calls:
            return message.content
        
        # Execute tool calls
        messages.append(message)
        
        for tool_call in message.tool_calls:
            function_name = tool_call.function.name
            arguments = json.loads(tool_call.function.arguments)
            
            # Execute function
            if function_name == "search_regulations":
                result = search_regulations(**arguments)
            elif function_name == "calculate_capital_ratio":
                result = calculate_capital_ratio(**arguments)
            
            # Add result to messages
            messages.append({
                "role": "tool",
                "tool_call_id": tool_call.id,
                "content": json.dumps(result)
            })
```

#### 2. ReAct (Reasoning + Acting)

**Pattern:** Alternate between reasoning and acting.

```python
def react_agent(query, max_steps=5):
    """ReAct agent for multi-step reasoning."""
    context = ""
    
    for step in range(max_steps):
        # Thought: Reason about next action
        thought_prompt = f"""Question: {query}

Previous actions and observations:
{context}

Thought: What should I do next?"""
        
        thought = llm_generate(thought_prompt)
        
        # Action: Decide which tool to use
        action_prompt = f"""{thought_prompt}
Thought: {thought}

Action (choose one: search_docs, calculate, query_database, finish):"""
        
        action = llm_generate(action_prompt).strip().lower()
        
        if action == "finish":
            # Final answer
            answer_prompt = f"""{context}

Question: {query}

Final Answer:"""
            return llm_generate(answer_prompt)
        
        # Execute action
        if action == "search_docs":
            observation = vector_search(query, top_k=3)
        elif action == "calculate":
            observation = execute_calculation(thought)
        elif action == "query_database":
            observation = query_database(thought)
        else:
            observation = "Invalid action"
        
        # Update context
        context += f"\nThought: {thought}\nAction: {action}\nObservation: {observation}\n"
    
    return "Max steps reached without conclusion"
```

#### 3. LangChain Agents

```python
from langchain.agents import create_openai_functions_agent, AgentExecutor
from langchain.tools import Tool
from langchain_openai import ChatOpenAI

# Define tools
tools = [
    Tool(
        name="VectorSearch",
        func=lambda q: vector_search(q, top_k=5),
        description="Search regulatory documents"
    ),
    Tool(
        name="CalculateRatio",
        func=calculate_financial_ratio,
        description="Calculate financial ratios (input: ratio_type, values)"
    ),
    Tool(
        name="QueryTransactions",
        func=query_transaction_db,
        description="Query transaction database"
    )
]

# Create agent
llm = ChatOpenAI(model="gpt-4", temperature=0)
agent = create_openai_functions_agent(llm, tools, prompt_template)
agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

# Execute
result = agent_executor.invoke({"input": "What is our current tier 1 capital ratio and does it meet Basel III requirements?"})
```

### Banking-Specific Tools

#### 1. Regulatory Search Tool

```python
def search_regulations(query, regulation_type=None, effective_date=None):
    """Search regulatory documents with filters."""
    filters = {}
    if regulation_type:
        filters['regulation_type'] = regulation_type
    if effective_date:
        filters['effective_date'] = {'$lte': effective_date}
    
    results = vector_search_with_filter(query, filters, top_k=5)
    return format_search_results(results)
```

#### 2. Financial Calculation Tool

```python
def calculate_financial_ratio(ratio_type, **kwargs):
    """Calculate various financial ratios."""
    if ratio_type == "tier1_capital_ratio":
        return kwargs['tier1_capital'] / kwargs['risk_weighted_assets']
    elif ratio_type == "leverage_ratio":
        return kwargs['tier1_capital'] / kwargs['total_assets']
    elif ratio_type == "liquidity_coverage_ratio":
        return kwargs['high_quality_liquid_assets'] / kwargs['net_cash_outflows']
    else:
        return {"error": "Unknown ratio type"}
```

#### 3. Database Query Tool

```python
def query_transaction_db(query_params):
    """Query transaction database."""
    # Parse natural language to SQL
    sql_query = nl_to_sql(query_params)
    
    # Execute with safety checks
    if is_safe_query(sql_query):
        results = execute_sql(sql_query)
        return results
    else:
        return {"error": "Unsafe query rejected"}
```

#### 4. Compliance Checker Tool

```python
def check_compliance(rule_id, entity_data):
    """Check if entity complies with regulation."""
    rule = load_compliance_rule(rule_id)
    
    # Evaluate rule
    result = evaluate_rule(rule, entity_data)
    
    return {
        "compliant": result['passed'],
        "violations": result['violations'],
        "recommendations": result['recommendations']
    }
```

### Multi-Agent Systems

**Approach:** Multiple specialized agents collaborate.

```python
class BankingRAGSystem:
    def __init__(self):
        self.retrieval_agent = RetrievalAgent()
        self.calculation_agent = CalculationAgent()
        self.compliance_agent = ComplianceAgent()
        self.coordinator = CoordinatorAgent()
    
    def process_query(self, query):
        """Coordinate multiple agents."""
        # Coordinator decides which agents to involve
        plan = self.coordinator.create_plan(query)
        
        results = {}
        for step in plan:
            if step['agent'] == 'retrieval':
                results[step['id']] = self.retrieval_agent.execute(step['params'])
            elif step['agent'] == 'calculation':
                results[step['id']] = self.calculation_agent.execute(step['params'])
            elif step['agent'] == 'compliance':
                results[step['id']] = self.compliance_agent.execute(step['params'])
        
        # Synthesize final answer
        return self.coordinator.synthesize(query, results)
```

**Industrial-Grade Aspect:** For banking, multi-agent systems enable:
- Retrieval agent: Finds relevant regulations
- Calculation agent: Computes financial metrics
- Compliance agent: Validates against rules
- Coordinator: Orchestrates workflow

### Safety and Guardrails

**Critical for Banking:**

```python
def safe_agentic_rag(query, user_permissions):
    """Agentic RAG with safety controls."""
    
    # 1. Query validation
    if not is_safe_query(query):
        return {"error": "Query rejected by safety filter"}
    
    # 2. Tool access control
    allowed_tools = get_allowed_tools(user_permissions)
    
    # 3. Execute with monitoring
    execution_log = []
    
    response = agent_executor.invoke(
        {"input": query},
        config={
            "allowed_tools": allowed_tools,
            "max_iterations": 5,
            "callbacks": [LoggingCallback(execution_log)]
        }
    )
    
    # 4. Output validation
    if contains_sensitive_data(response):
        response = redact_sensitive_data(response)
    
    # 5. Audit logging
    log_agent_execution(query, execution_log, response, user_permissions)
    
    return response
```

### Best Practices

1. **Tool Documentation:** Clear descriptions for LLM to understand when to use each tool
2. **Error Handling:** Graceful degradation if tools fail
3. **Rate Limiting:** Prevent excessive API calls
4. **Access Control:** Restrict tools based on user permissions
5. **Audit Logging:** Track all tool executions for compliance

### Summary

Agentic RAG transforms passive retrieval into active problem-solving. Key takeaways:

- **Tool integration** enables actions beyond retrieval
- **ReAct pattern** alternates reasoning and acting
- **Banking tools**: Regulatory search, calculations, database queries, compliance checks
- **Multi-agent systems** coordinate specialized agents
- **Safety guardrails** essential for banking applications

Next, we'll explore multi-modal RAG for handling images and tables.
